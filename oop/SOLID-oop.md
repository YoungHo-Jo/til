# SOLID 객치 지향 설계
#CS/oop

로버트 마틴이 2000년 초반 명명한 OOP 및 설계 다섯 가지 기본 원칙을 마이클 패더스가 두문자어 기억술로 소개한 것이다.

유지 보수와 확장이 쉬운 시스템을 개발하고싶을떄 이 원칙을 적용할 수 있다.
코드가 읽기 쉽고
확장하기 쉽게 될 때까지 리팩토링하여 
코드 스멜을 제거하기 위해 적용할 수 있다.
애쟈일과 적응적 소프트웨어 개발 전반적 전략의 일부다.

## 개요
* SRP
단일 책임 원칙(Single Responsibility Principle)
한 클래스는 하나의 책임만 가져야 한다.
모든 클래스는 하나의 책임만 가진다.
**책임을 완전히 캡슐화 해야한다**
제공하는 모든 기능은 책임과 부합해야한다.

~예~
보고서를 편집하고 출력하는 모듈
두 가지 이유로 변경 가능
1. 보고서의 내용에 의해
2. 보고서의 형식에 의해
하나는 실질적이며 하나는 꾸미기 위한 다른 원인에 기인
SRP는 이 문제의 두 측면이 실제로 분리된 두 책임 떄문이며, **따라서 분리된 클래스나 모듈로 나누어야한다.**
다른 시기, 이유로 변경되어야 하는 두 가지를 묶는 것은 나쁜 설계일 수 있다.
**한 클래스를 한 관심사에 집중**하도록 유지하는 이유는, 클래스를 더욱 튼튼하게 만들어주기 떄문이다. 


* OCP
개방-폐쇄 원칙(Open/Close Principle)
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀있어야 한다.
개발에 이용된 모듈 중 하나에 수정을 가할 때 그것을 이용하는 다른 모듈을 줄줄이 고쳐야하면 해당 프로그램은 수정하기 어렵다. 
OCP는 **시스템의 구조를 올바르게 리팩토링**하여 나중에 이와 같은 유형의 **변경이 더 이상의 수정을 유발하지 않도록 하는 것**이다.
잘 적용되면, 기능 추가/변경시에 제대로 동작하고 있던 코드는 **변경하지 않아도**, 새로운 코드를 추가함으로써 기능의 추가나 변경이 가능하다.

1. 확장에 대해 열려 있다.
**동작을 확장할 수 있다**는 것을 의미한다. 요구 사항 변경시 새로운 동작을 추가해 확장
**모듈이 하는 일을 변경할 수 있다**
2. 수정에 대해 닫혀 있다.
코드를 **수정하지 않고** 모듈의 기능을 **확장하거나 변경**가능하다. 

**추상화를 통해 OCP를 달성할 수 있다.**
abstract같은 고성된 추상화가 있지만 interface나 abstract method를 새로 정의하므로써 기능의 확장이 가능하다. 

위의 법칙을 잘 지켜야 OOP의 **유연성, 재사용성, 유지보수성** 등을 얻을 수 있다. 반드시 지켜야할 **기본 원칙**이다.


* LSP
리스코프 치환 원칙(Liskov Substitution Principle)
프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다. 계약에 의한 설계를 참고


* ISP
인터페이스 확장 원칙(Interface Segregation Principle)
특정 클라이언트를 위한 인터페이스 여러 개가 범용 하나보다 낫다.

클라이언트가 자신이 이용하지 않는 메소드에 의존하지 않아야 한다는 원칙이다. 
큰 덩어리의 인터페이스들을 **구체적이고 작은 단위로 분리**시켜 필요한 메소드만 이용할 수 있게 한다. 
작은 단위 인터페이스를 ~역할 인터페이스~라고 한다. 
내부 의존성을 약화시키고, 리팩토링, 수정, 재배포를 쉽게 한다. 


* DIP
의존관계 역전 법칙(Dependency Inversion Principle)
프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다”
DI는 이 원칙을 따르는 방법 중 하나
[[DI: Dependency Injection]]
상위 계층이 하위 계층의 구현으로부터 독립되게 한다. 
1. 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.
2. 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.

**상위와 하위 객체 모두가 동일한 추상화에 의존해야 한다**는 OOP 설계 대원칙을 제공한다.




## 참조
[위키피디아](https://ko.wikipedia.org/wiki/SOLID_(객체_지향_설계))

